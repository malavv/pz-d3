<link rel="import" href="../polymer/polymer.html">

<script src="https://d3js.org/d3.v4.min.js"></script>

<!--
  `pz-bar-chart` is a Bar Chart element.
-->
<dom-module id="pz-chart">
  <template>
    <style>
      svg {
        background-color: #ccc;
      }
    </style>
    <svg> </svg>
    <content id="content"></content>
  </template>
</dom-module>

<script>
(function() {
  'use strict';

  Polymer({
    is: 'pz-chart',

    properties: {},

    getAxis() {
      return this.getEffectiveChildren().filter(n => /pz-axis/.test(n.localName));
    },
    getMarkers() {
      return this.getEffectiveChildren().filter(n => /pz-(bars|points)/.test(n.localName));
    },

    attached() {
      this.height = 500;
      this.width = 500;
      this.scales = {};
      this.padding = {top: 10, right: 10, bottom: 50, left: 50};
      this.meta = this.parentElement.meta;
      this.data = this.parentElement.data.filter(o => o[0] === 2009);

      this.data = this.sortDataForMarker(this.getMarkers()[0], this.meta, this.data);

      this.svg = d3.select(Polymer.dom(this.root).querySelector('svg'))
          .attr("width", this.width + this.padding.left + this.padding.right)
          .attr("height", this.height + this.padding.top + this.padding.bottom);
      this.graph = this.svg.append("g")
            .attr("class", "graph")
            .attr("transform", "translate(" + this.padding.left + "," + this.padding.top + ")");

      this.getAxis().forEach(axis => this.addAxis(axis));
      this.getMarkers().forEach(marker => this.addMarker(marker))
    },

    sortDataForMarker(marker, meta, data) {
        let idx = meta.map(m => m.ref).indexOf(marker.valueKey());
        return data.sort((lhs, rhs) => lhs[idx] - rhs[idx]);
    },

    addAxis(axis) {
      let
        meta = this.meta,
        data = this.data

      // TODO(malavv) : Managing multiple y axis.
      if (axis.orient === 'left') {
        let scale = axis.scale(meta, data).rangeRound([this.height, 0]);
        this.graph.append("g")
          .attr("class", "axis")
          .call(axis.axis(scale));
        this.scales[axis.key] = scale;
        return;
      }
      if (axis.orient === 'bottom') {
        let scale = axis.scale(meta, data).range([0, this.width]).round(true).padding(0.1);
        this.graph.append("g")
          .attr("class", "axis")
          .attr("transform", "translate(0," + this.height + ")")
          .call(axis.axis(scale))
          .selectAll("text")
            .attr("y", 0)
            .attr("x", 9)
            .attr("dy", ".35em")
            .attr("transform", "rotate(90)")
            .style("text-anchor", "start");
        this.scales[axis.key] = scale;
        return;
      }
    },

    addMarker(marker) {
      let
        meta = this.meta,
        data = this.data;

      // Fake Data
      let barData = [];
      for (let i = 1; i <= 10; i++)
        barData.push(i.toString());

      // x and y scales.
      let xScale = this.scales[marker.x];
      let yScale = this.scales[marker.valueKey()];

      this.graph.selectAll(".bar")
        .data(data)
        .enter().append(marker.ns())
          .attr("class", "bar")
          .attr('fill', '#4ba99f')
          .call(marker.draw(xScale, yScale, this.meta, this.height));
    }
  });
})();
</script>
